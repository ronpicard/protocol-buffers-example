import socket
import struct
import threading
import time
from pathlib import Path
import sys

# Add current working directory to Python's import path so we can import the generated module
# This ensures that when running from repo root, `protos/example_pb2.py` can be imported
sys.path.insert(0, str(Path(".").resolve()))

# Import the generated Python code from example.proto
# Generated by running: protoc --python_out=. protos/example.proto
from protos import example_pb2

# Network configuration
HOST = "127.0.0.1"   # Loopback address for local-only communication
PORT = 50051         # Arbitrary TCP port (must be free on the system)


# -------------------
# Utility Functions
# -------------------

def send_with_length(sock: socket.socket, payload: bytes) -> None:
    """
    Send a payload over a socket, prefixed with a 4-byte big-endian length.

    Why:
      TCP is a stream protocol — it does not preserve message boundaries.
      Without framing, the receiver would not know where one message ends
      and the next begins.

    How it works:
      1. struct.pack(">I", len(payload)) converts the integer length into
         4 bytes, big-endian unsigned int format.
      2. Concatenate the length prefix and the payload.
      3. Use sock.sendall() to ensure all bytes are sent before returning.

    Example wire format for "ABC":
      00 00 00 03 41 42 43
      |  length=3 | data |
    """
    sock.sendall(struct.pack(">I", len(payload)) + payload)


def recv_exact(sock: socket.socket, n: int) -> bytes:
    """
    Receive exactly n bytes from a socket.

    Why:
      TCP delivers data in chunks, so one recv() call may return fewer bytes
      than requested. We must loop until we've collected the full length.

    Steps:
      1. Initialize an empty buffer.
      2. Read from the socket until the buffer contains exactly n bytes.
      3. If recv() returns b"", the connection was closed — raise an error.

    Example:
      If n=5 and the network delivers [b'He', b'llo'], this will combine them
      into b'Hello' before returning.
    """
    buf = b""
    while len(buf) < n:
        chunk = sock.recv(n - len(buf))
        if not chunk:
            raise ConnectionError("Socket closed while receiving data.")
        buf += chunk
    return buf


def recv_with_length(sock: socket.socket) -> bytes:
    """
    Read a 4-byte length prefix, then read exactly that many bytes of payload.

    Why:
      Complements send_with_length() — first read the message size,
      then read the payload.

    Steps:
      1. Read 4 bytes from the socket.
      2. struct.unpack(">I", raw_len) converts those bytes to an integer.
      3. Read exactly msg_len bytes for the payload.

    Example wire format:
      [00 00 00 0A][data...10 bytes...]
       length=10    payload
    """
    raw_len = recv_exact(sock, 4)
    (msg_len,) = struct.unpack(">I", raw_len)
    return recv_exact(sock, msg_len)


# -------------------
# Server Function
# -------------------

def server():
    """
    TCP server that listens on HOST:PORT, receives a protobuf message,
    and prints the parsed fields.
    """
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind((HOST, PORT))
        s.listen(1)
        print(f"[server] listening on {HOST}:{PORT}")

        # Accept a single incoming connection
        conn, addr = s.accept()
        with conn:
            print(f"[server] connection from {addr}")

            # Receive framed protobuf message
            data = recv_with_length(conn)

            # Deserialize the protobuf payload into a Person object
            person = example_pb2.Person()
            person.ParseFromString(data)

            # Display parsed message fields
            print("[server] received Person message:")
            print(f"         name={person.name}, id={person.id}, email={person.email}")


# -------------------
# Client Function
# -------------------

def client():
    """
    TCP client that connects to the server, creates a protobuf Person message,
    serializes it, and sends it using the length-prefixed protocol.
    """
    # Create a Person protobuf object
    person = example_pb2.Person(
        name="Ada Lovelace",
        id=42,
        email="ada@example.com"
    )

    # Serialize protobuf object to bytes
    payload = person.SerializeToString()

    # Connect to server and send framed message
    with socket.create_connection((HOST, PORT), timeout=5) as sock:
        send_with_length(sock, payload)
        print("[client] sent Person message")


# -------------------
# Main Function
# -------------------

def main():
    """
    Launch server in a background thread, then run the client.
    This simulates both ends of the communication on the same machine.
    """
    # Start server in background thread
    t = threading.Thread(target=server, daemon=True)
    t.start()

    # Give server time to bind and listen
    time.sleep(0.2)

    # Run client to send message
    client()

    # Allow server to process message before script exits
    time.sleep(0.2)


# Script entry point
if __name__ == "__main__":
    main()
